
应用HTTP协议的时候,必须一端是客户端角色,另外一端是服务器端角色
在两台计算机之间使用HTTP协议通信的时候,在一条通信线路上必定一端是客户端,另外一端是服务器端

有时候两台计算机作为客户端和服务器端的角色有可能会互换,但就一条通信路线而言,服务器端盒客户端的角色是确定的,但是HTTP端能区分哪个是客户端,哪个是服务器端
>请求必定由客户端发出，而服务器端回复响应
>换句话说，肯定是先从客户端开始建立通信的，服务器端在没有 接收到请求
>之前不会发送响应

### 请求报文
```http
GET /index.htm HTTP/1.1 
Host: hackr.jp
```

Get表示的事请求访问服务器的类型,成为方法

随后的指明了请求访问的资源对象,也叫做request-URI,最后的表示的事客户端的HTTP版本号
HOST表示服务器的域名,会被DNS解析成ip地址

这段话的意思是,请求访问某台HTTP服务器上的`/index.html`文件

**请求报文是由请求方法,请求URI,版本协议,可选的请求首部字段和内容实体构成的**
![](HTTP/attachments/Pasted%20image%2020250121190112.png)
接受到请求的服务器,会将内容的处理结果以相应报文的形式返回
```http
HTTP/1.1 200 OK 
Date: Tue, 10 Jul 2012 06:50:15 GMT 
Content-Length: 362 
Content-Type: text/html

<html>
......
```
HTTP/1.1表示服务器对应的HTTP版本
紧接着的`200ok`表示请求的处理结果状态码,和原因短语.
下一行显示了创建想要的日期时间,是首部字段内的一个属性
接着以一空行分隔，之后的内容称为资源实体的主体

```html
<html>后面的都是主要内容
```

### HTTP是不保存状态的协议
HTTP是一种无状态协议,自身不对请求和响应的通信状态进行保存,也就是说在HTTP这个级别,协议对于发送过的请求或者响应都不做持久化处理

HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能,于是引入了Cookie技术
### 请求使用URI定位资源
HTTP协议使用URI定位互联网上的资源,正是因为URI的特定功能,在互联网上任意位置的资源都能访问到

在我们发送请求的时候,需要把URI包括在内

有很多种形式
1. 直接URI为完整的请求URI
	`GET http://google.com/index/html HTTP/1.1`
2. 在首部字段HOST中写明网络域名或者IP地址
	`GET index/heml HTTP/1.1`
	`Host: google.com`
除此之外，如果不是访问特定资源而是对服务器本身发起请求，可 以用一个\*来代替请求URI。下面这个例子是查询HTTP服务器端支持的HTTP方法种类。

```html
OPTIONS * HTTP/1.1
```
### 告知服务器意图的HTTP方法

#### GET

get方法用来请求已经被识别的URI的资源,如果请求的资源是文本,那就保持原样返回,如果是像CGI(Common Gateway Interface，通用网关接口)一样的程序,就返回经过执行之后的输出结果


#### POST
POST方法用来传输实体的主体,POST 的主要目的并不是获取响应的主体内容

把信息告诉服务器
![](HTTP/attachments/Pasted%20image%2020250121195534.png)
#### PUT
PUT 方法用来传输文件,要在报文主体中包含文件内容,并且保存在请求URI制定的位置上

一般web不使用这个方法,因为HTTP自身的put不带验证机制,任何人都可以上传文件

一般配合好web应用的验证机制,挥着用rest标准的同类方法会开放使用put方法
![](HTTP/attachments/Pasted%20image%2020250121195747.png)

#### HEAD

HEAD用来返回报文的URI有关的响应首部,不返回主体,用来确认URI的有效性和资源更新的时间
#### DELETE

delete删除文件,和put是相反的方法,delete方法按照请求URI删除指定的资源

但是HTTP1.1的`delete`方法本身和`put`方法一样不带上验证机制,所以一般的web方法也不遵守delete方法,当配合web应用程序的验证机制,遵守rest标准时还是有可能开放使用的

#### options:询问支持的方法
```http
OPTIONS * HTTP/1.1 
Host: www.hackr.jp
```

相应
```http
HTTP/1.1 200 OK 
Allow: GET, POST, HEAD, OPTIONS
```
#### TRACE：追踪路径
在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码`200 OK`的响应

通常不会用到(我也没看懂)
#### CONNET:要求用隧道协议连接代理
CONNECT方法要求在与代理服务器通信时**建立隧道**，实现用隧道协议进行TCP通信

主要使用**SSL**（Secure Sockets Layer，安全套接层）和**TLS**（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输

![](HTTP/attachments/Pasted%20image%2020250121200710.png)








## 使用方法下达命令

>向请求URI指定的资源发送请求报文时，采用称为**方法**的命令。

方法作用在于,可以制定请求的资源按照期望来产生某轴行为,方法中又GET,POST和HEAD

另外，方法名区分大小写，注意要用**大写字母**
![](HTTP/attachments/Pasted%20image%2020250121200906.png)

## 持久连接节省信息量
持久连接的特点是，*只要任意一端没有明确提出断开连接*，则保持TCP连接状态

可以减轻服务负担,并且加快web显示速度

在HTTP/1.1 中，所有的连接默认都是持久连接

### 管线化

持久连接使得多数请求以管线化的方式发送成为可能

从前发送请求后需要等待并且收到相应,才能发送下一个请求,管线化技术出现后,不用等待响应也可以直接发送下一个请求

这样就能够做到同时并行发送多个请求,而不需要一个一个等待了

![](HTTP/attachments/Pasted%20image%2020250121201237.png)

以前是这样的
![](HTTP/attachments/Pasted%20image%2020250121201252.png)
请求数越多，时间差就越明显
## cookie状态管理
HTTP是无状态协议,它不对之前发生过的请求和响应的状态进行管理,也就是说无法根据之前的状态进行本次的请求管理

一方面减少了服务器的CPU和内存资源的小号,另外也使得http非常简单,会被应用到各种场合里面

保留无状态协议这个特征的同时还要解决类似的矛盾问题,于是引入了Cookie技术,Cookie技术在请求和响应报文中写入cookie信息来控制客户端的状态

cookie会根据从服务器发送的响应报文内的一个叫做SET-cookie的首部字段信息,通知客户端保存cookie,下次客户端再次发送请求的时候,会自动在请求报文中加入cookie值之后再发送出去

服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息
```http
GET /image/ HTTP/1.1 
Host: hackr.jp 
Cookie: sid=1342077140226724
```
服务器端生成cookie信息作为响应报文信息,然后客户端才能在请求报文中加入cookie
```http
HTTP/1.1 200 OK 
Date: Thu, 12 Jul 2012 07:12:20 GMT 
Server: Apache ＜Set-Cookie: sid=1342077140226724; path=/; =>expires=Wed, 10-Oct-12 07:12:20 GMT＞ 
Content-Type: text/plain; 
charset=UTF-8
```